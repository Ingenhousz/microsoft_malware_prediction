from util import *
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import LogisticRegressionCV
from scipy.sparse import csc_matrix
from sklearn.linear_model import BayesianRidge
from sklearn.model_selection import RepeatedKFold


def stacking(train, test, y_train, train_ids, test_ids):

    debug = False
    counter = 0
    m = 10**5
    y_train = np.array(y_train)
    num_fold = 2 if debug else 5
    skf = RepeatedKFold(n_splits=num_fold, n_repeats=2, random_state=777)
    skf.get_n_splits(train_ids, y_train)

    test_result = np.zeros(test_ids.shape[0])
    train_result = np.zeros(train_ids.shape[0])
    scores = []

    print(train.shape)

    print('\nstacking\n')

    for train_index, test_index in skf.split(train_ids, y_train):

        print('\nFold {}\n'.format(counter + 1))

        # X_fit = vstack([train[train_index[i * m:(i + 1) * m]] for i in range(train_index.shape[0] // m + 1)])
        # X_val = vstack([train[test_index[i * m:(i + 1) * m]] for i in range(test_index.shape[0] // m + 1)])

        X_fit = train[train_index, ].toarray()
        X_val = train[test_index, ].toarray()
        # X_fit, X_val = csr_matrix(X_fit, dtype='float32'), csr_matrix(X_val, dtype='float32')
        y_fit, y_val = y_train[train_index], y_train[test_index]

        # clf = LogisticRegressionCV(penalty='l2', Cs=[10, 1, .1, .001], n_jobs=-1, verbose=10,
        #                            random_state=777, scoring='roc_auc')

        # clf = LogisticRegression(penalty='l1', random_state=777, n_jobs=-1, C=0.5, verbose=10)

        clf = BayesianRidge()
        clf.fit(X_fit, y_fit)

        train_result[test_index] += clf.predict(X_val)  # [:, 1]
        scores.append(fast_auc(y_val, train_result[test_index]))

        del X_fit, X_val, y_fit, y_val, train_index, test_index
        gc.collect()

        # test = csr_matrix(test, dtype='float32')
        test_result += clf.predict(test)  # [:, 1]
        counter += 1

    score = np.mean(scores)
    # train_result = train_result/num_fold ## wrong
    test_result = test_result/num_fold

    del train_result
    gc.collect()

    return test_result, round(score, 3)


def main():
    ada_train, ada_test = read_from_pickle('input/meta_ada.pkl')
    gbdt_train, gbdt_test = read_from_pickle('input/meta_lgbm_gbdt.pkl')
    goss_train, goss_test = read_from_pickle('input/meta_lgbm_goss.pkl')

    # ada_train = ada_train * 5
    gbdt_train = gbdt_train * 5
    goss_train = goss_train * 5

    print('training size:', len(ada_train))

    print(max(ada_train), max(ada_test))
    print(max(gbdt_train), max(goss_train))

    meta_train = np.vstack((ada_train, gbdt_train, goss_train))
    meta_test = np.vstack((ada_test, gbdt_test, goss_test))

    # meta_train = np.float32(meta_train)
    # meta_test = np.float32(meta_test)
    meta_train, meta_test = csr_matrix(meta_train.T, dtype='float32'), csr_matrix(meta_test.T, dtype='float32')

    train, test = read_pickle()
    y_train = train['HasDetections']
    train_ids = train.index
    test_ids = test.index

    del train, test, ada_train, ada_test, gbdt_train, gbdt_test, goss_train, goss_test
    gc.collect()

    test_result, score = stacking(meta_train, meta_test, y_train, train_ids, test_ids)

    save_submission(test_result, score, 'stacking_cor')
    return


if __name__ == '__main__':
    main()
